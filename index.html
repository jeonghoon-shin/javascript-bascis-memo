<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Hello World</h1>
    <script src="index.js"></script>
</body>
</html>

<!--
    ===============+===============+===============+===============

    JavaScript Tutorial for Beginners: Learn JavaScript in 1 Hour [2019]
    https://www.youtube.com/watch?v=W6NZfCO5SIk

    ===============+===============+===============+===============

    -자바스크립트를 body 밑에서 로딩하는 이유
    1. 컨텐츠를 스크립트보다 먼저 로딩해서 체감되는 대기 시간을 줄이기
    2. 컨텐츠와 스크립트가 상호작용해야하기 때문에 컨텐츠부터 로딩 

    -관심사의 분리 (Separation of Concern)
    자바스크립트와 HTML을 분리

    ===============+===============+===============+===============

    -변수 선언
    var, let, const

    -변수명
    1. 예약된 키워드는 쓸 수 없다
    2. 의미있는, 설명해주는 이름으로 짓자
    3. 숫자로 시작하면 안된다
    4. 공백이나 하이픈(-)을 넣을 수 없다
    5. Are case-sensitive
    6. 모던 자바스크립트에서는 다른 변수는 각각 여러 줄에서 선언

    -프리미티브 / 값 타입
    1. String
    2. Number
    3. Boolean
    4. undefined
    5. null

    -typeof [변수명 or 값]

    ===============+===============+===============+===============

    -레퍼런스 타입
    1. Object - 실세계의 대상들을 속성으로 표현
    2. Array
    3. Function

    ===============+===============+===============+===============

    -객체 리터럴(Object Literal)
    let obj = { key: value, ... };

    --점 표기법(Dot Notation)
    obj.key = 'This is String Literal';

    --브라켓 표기법(Bracket Notation)
    // 런타임 중 속성(프로퍼티)을 알아내서 동적으로 접근할 수 있음
    let selection = 'name';
    obj[selection] = 'This is String Literal';

    ===============+===============+===============+===============

    -배열
    1. 요소들의 목록을 표현하는데 사용되는 자료 구조
       (Data structure that we use to represent a list of items)
    2. 객체의 일종이다
       따라서 점 표기법으로 원소에 접근할 수 있다
    3. Square Bracket 으로 배열 리터럴을 선언할 때마다 자동으로 Property(속성)이 같이 선언된다

    -배열 리터럴(Array Literal)
    let arr = ['valueOne', 'valueTwo', ...];

    -배열의 크기
    동적으로 변경할 수 있다
    arr[2] = 'valueThree'; // ['valueOne', 'valueTwo', 'valueThree']
    arr[3] = 'valueFour';  // ['valueOne', 'valueTwo', empty, 'valueFour']

    -배열의 원소의 타입
    변수와 마찬가지로 동적으로 타입을 바꿀 수 있다

    ===============+===============+===============+===============

    -function
    function funcName(var1, var2, ...) {}
    
    --파라미터: 선언부
    --아규먼트: 호출부, 실제 값

    ===============+===============+===============+===============

    -Power Operator
    2 ** 2

    -Strict Equality Operator (Type + Value)
    x === 1
    x !== 1

    -Lose Eqality Operator (Value)
    1 == 1 // true
    '1' == 1 // true
    true == 1 // true (true가 1로 변환됨)

    -논리적 연산자는 operand가 boolean일 필요는 없음

    -Falsy (false) value
    undefined, null, 0, false, '', NaN

    -Short-circuiting
    https://codeburst.io/javascript-what-is-short-circuit-evaluation-ff22b2f5608c
    OR 연산에서 첫번째 값이 Truthy라면 두번째 Operand가 무시되는 현상

    --예제
    let v = false || 1 || 2; // (false || 1) || 2
    console.log(v); // 1

    1이 Truthy 값이기 때문에 2는 무시됨.

    --왼쪽 값이 Falsy하면 우측의 값을 대입하는데 사용됨
    let userColor; // undefined
    let defaultColor = 'red';
    console.log(userColor || defaultColor); // red

    ===============+===============+===============+===============

    -Bitwise Operation Example // Read, Write, Execute
    const readPermission = 4;       // 00000100
    const writePermission = 2;      // 00000010
    const executePermission = 1;    // 00000001

    let myPermission = 0;
    myPermission = myPermission | readPermission | writePermission;

    let message = (myPermission & readPermission) ? 'yes' : 'no';
    console.log(message);

    ===============+===============+===============+===============

    -for-in loop
    for (let key in obj) { // 값이 아닌 키 이름이 나옴
        console.log(obj[key]); // braket notation을 이용해 프로퍼티 이름으로 값에 접근
    }

    for (let index in arr) { // 값이 아닌 인덱스 번호가 나옴
        console.log(arr[index]);
    }

    -for-of loop
    배열 안의 원소를 순회
    for (let element of arr) {
        console.log(element);
    }

    ===============+===============+===============+===============

    -스코프 안에서 선언시에 대입된 후 값이 바뀌지 않는 변수는 상수로 선언하는게 좋다

    -관련이 높은 라인들끼리는 붙여주는게 좋고, 그렇지 않으면 떨어뜨리는게 좋다

    ===============+===============+===============+===============

    -Single Responsibility Principle
    하나의 모듈 (객체, 함수 등)은 하나의 작은 역할(책임) 만을 지게하는 것

    -nested loop: 중첩된 루프

    ===============+===============+===============+===============

    -객체를 생성하는 다양한 방법

    --Object Literal 방식
    const circle = {
        radius: 1, 
        location: {         // 값은 객체가 들어갈수도 있고
            x: 1,
            y: 1
        },
        isVisible: true,
        draw: function() {  // 함수(메서드)가 들어갈수도 있다.
            console.log('draw');
        }
    };
    // 여러 동일한 객체를 만들려면 복사 붙여넣기를 해야 하는 단점.

    ===============+===============+===============+===============

    --Factory Function 방식
    객체 리터럴을 반환하는 함수
    네이밍에 Camel Notation 사용 (oneTwoThree)

    아규먼트를 값으로 대입하는 경우 키 값을 생략하면 아규먼트 이름과 동일하게 만들어짐
    메서드는 function() {} 형태로 Function Literal 대입 없이 선언 가능

    // Hard Coding
    function createCircle() {
        return {
            radius: 1,
            location: {
                x: 1,
                y: 1
            },
            isVisible: true,
            draw: function() {  // Function Literal
                console.log('draw');
            },
        };
    }

    // 일반화
    function createCircle(radius, location, isVisible) {
        return {
            radius: radius,
            location: location,
            isVisible: isVisible,
            draw: function() {
                console.log('draw');
            },
        };
    }

    // 간단하게 표현하는 방법
    function createCircle(radius, location, isVisible) {
        return {
            radius,
            location,
            isVisible
            draw() {
                console.log('draw');
            },
        };
    }

    // 선언, 초기화, 사용
    const circle = createCircle(1, { x:1, y:1 }, true);
    console.log(circle);
    circle.draw();

    ===============+===============+===============+===============

    --Constructor Function
    객체를 생성하는 함수
    네이밍에 Pascal Notation 사용 (OneTwoThree)
    
    function Circle(radius, location, inVisible) {
        this.radius = radius;
        this.location = location;
        this.isVisible = isVisible;
        this.draw = function() {
            console.log('draw');
        }

        // return this; 는 생략됨
    }

    let circle = new Circle(1, { 1, 1 }, true);

    -new 키워드: 빈 객체를 생성함 ( {} )
    사용하지 않으면 함수는 전역 객체를 변경하게 됨

    -this 키워드: new 키워드로 만들어진 객체를 지정함
    없을 때는 전역 객체를 변경

    -
    
    ===============+===============+===============+===============

    // const는 이미 만들어진 속성에 값을 다시 대입할 수 없을 뿐
    const circle = {
        radius: 1
    }

    // const에 객체의 속성과 값을 동적으로 추가할 수 있다
    circle.color = 'yellow';
    circle.draw = function() {};

    // 지울 수도 있다
    delete circle.color;
    delete circle.draw;

    ===============+===============+===============+===============
    
    -Constructor Property
    객체를 생성할 때 사용된 함수

    obj.constructor 로 볼 수 있다

    리터럴은 생성자 호출과 같음
    new Object(); // {}
    new String(); // '', "", ``
    new Boolean(); // true, false
    new Number(); // 1, 2, 3, ...

    // 함수 
    function Circle(radius) {
        this.radius = radius;
        this.draw - function() {
            console.log('draw');
        }
    }

    const Circle = new Function('radius', `
        this.radius = radius;
        this.draw = function() {
            console.log('draw');
        }
    `);
    
    new Circle(1);
    // Circle.call({}, 1);
    // Circle.apply({}, [1]); // 배열

    ===============+===============+===============+===============

-->